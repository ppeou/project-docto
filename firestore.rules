rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isCreator() {
      return isAuthenticated() && 
             resource.data.created.by == request.auth.uid;
    }
    
    function willBeCreator() {
      return isAuthenticated() && 
             request.resource.data.created.by == request.auth.uid;
    }

    // Itinerary membership helpers
    // For backward compatibility, treat creator as a member if memberIds is missing or empty.
    function isItineraryMemberDoc(doc) {
      return isAuthenticated() && (
        doc.data.created.by == request.auth.uid ||
        (doc.data.memberIds != null && request.auth.uid in doc.data.memberIds)
      );
    }

    function isItineraryMember() {
      return isItineraryMemberDoc(resource);
    }

    function willBeItineraryMember() {
      // For new documents, check if user is the creator
      // Note: We can't easily check array membership in Firestore rules,
      // so we rely on created.by check for creation
      return isAuthenticated() && 
             request.resource.data.created.by == request.auth.uid;
    }

    function isNotDeleted() {
      return resource.data.isDeleted == false;
    }

    function willNotBeDeleted() {
      return request.resource.data.isDeleted == false;
    }

    // Admin user IDs - must match ADMIN_USER_IDS in src/services/admin.js
    function isAdmin() {
      return isAuthenticated() && 
             (request.auth.uid == '0JUzMFus8zLnHUr6p2FYMR7nvtY2' ||
              request.auth.uid == '25uMgxju8GUskuqim5R3CnLdQQi1' ||
              request.auth.uid == 'j78F2lp1IabzfJR2oTvYiIoqInT2' ||
              request.auth.uid == 'rsDCRyBC0yN1slA45MVwTjraTPz1' ||
              request.auth.uid == 'uea5ozO3ZsPArk3iwiscwvVJBCi2');
    }

    // Users collection
    match /users/{userId} {
      // Allow read if user owns the document (even if it doesn't exist yet)
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow create: if isOwner(userId) && 
                       request.resource.data.id == request.auth.uid &&
                       request.resource.data.email == request.auth.token.email;
      allow update: if isOwner(userId);
      allow delete: if false;
    }

    // Patients collection
    match /patients/{patientId} {
      // Allow read if user owns the patient and it's not deleted, or if user is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (resource.data.userId == request.auth.uid && isNotDeleted()));
      
      // Allow create if user sets themselves as owner, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (request.resource.data.userId == request.auth.uid &&
                         request.resource.data.created.by == request.auth.uid));
      
      // Allow update if user owns the patient
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.created.by == resource.data.created.by;
      
      // Allow delete (soft delete) if user owns the patient or is admin
      allow delete: if isAuthenticated() && 
                       (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Doctors collection
    match /doctors/{doctorId} {
      // Allow read if user owns the doctor and it's not deleted, or if user is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (resource.data.userId == request.auth.uid && isNotDeleted()));
      
      // Allow create if user sets themselves as owner, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (request.resource.data.userId == request.auth.uid &&
                         request.resource.data.created.by == request.auth.uid));
      
      // Allow update if user owns the doctor
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.created.by == resource.data.created.by;
      
      // Allow delete (soft delete) if user owns the doctor or is admin
      allow delete: if isAuthenticated() && 
                       (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Itineraries collection
    match /itineraries/{itineraryId} {
      // Allow read if user is a member and it's not deleted, or if user is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (isItineraryMember() && isNotDeleted()));
      
      // Allow create if user is the creator and required fields are present, or if admin creates for any user.
      // For new documents, either created.by must be the current user OR memberIds must contain the current user.
      allow create: if isAuthenticated() && 
                       request.resource.data.name is string &&
                       request.resource.data.name.size() > 0 &&
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (willBeCreator() && willBeItineraryMember()));
      
      // Allow update if user is a member and doesn't change soft-delete status
      // Ownership (created.by) must remain the same
      allow update: if isAuthenticated() && 
                       isItineraryMember() &&
                       request.resource.data.created.by == resource.data.created.by &&
                       request.resource.data.isDeleted == resource.data.isDeleted;
      
      // Allow delete (soft delete) if user is the creator/owner or is admin
      allow delete: if isAuthenticated() && (isCreator() || isAdmin());
    }

    // Appointments collection
    match /appointments/{appointmentId} {
      // Helper function to check if user is a member of the parent itinerary
      function itineraryMemberForAppointment() {
        return resource.data.itineraryId != null &&
               exists(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)) &&
               isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)));
      }
      
      // Allow read if user is a member of the parent itinerary or is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (itineraryMemberForAppointment() && isNotDeleted()));
      
      // Allow create if user is a member of the target itinerary and required fields are present, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       request.resource.data.title is string &&
                       request.resource.data.title.size() > 0 &&
                       request.resource.data.appointmentDate is timestamp &&
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (request.resource.data.itineraryId != null &&
                         exists(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)) &&
                         isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)))));
      
      // Allow update if user is a member of the parent itinerary and doesn't change ownership or soft-delete state
      allow update: if isAuthenticated() && 
                       itineraryMemberForAppointment() &&
                       request.resource.data.created.by == resource.data.created.by &&
                       request.resource.data.isDeleted == resource.data.isDeleted;
      
      // Allow delete (soft delete) if user is a member of the parent itinerary or is admin
      allow delete: if isAuthenticated() && (itineraryMemberForAppointment() || isAdmin());
    }

    // Prescriptions collection
    match /prescriptions/{prescriptionId} {
      // Helper function to check if user is a member of the parent itinerary
      function itineraryMemberForPrescription() {
        return resource.data.itineraryId != null &&
               exists(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)) &&
               isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)));
      }
      
      // Allow read if user is a member of the parent itinerary or is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (itineraryMemberForPrescription() && isNotDeleted()));
      
      // Allow create if user is a member of the target itinerary and required fields are present, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       request.resource.data.medicationName is string &&
                       request.resource.data.medicationName.size() > 0 &&
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (request.resource.data.itineraryId != null &&
                         exists(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)) &&
                         isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)))));
      
      // Allow update if user is a member of the parent itinerary and doesn't change ownership or soft-delete state
      allow update: if isAuthenticated() && 
                       itineraryMemberForPrescription() &&
                       request.resource.data.created.by == resource.data.created.by &&
                       request.resource.data.isDeleted == resource.data.isDeleted;
      
      // Allow delete (soft delete) if user is a member of the parent itinerary or is admin
      allow delete: if isAuthenticated() && (itineraryMemberForPrescription() || isAdmin());
    }

    // Doctor Notes collection
    match /doctorNotes/{noteId} {
      // Helper function to check if user is a member of the parent itinerary
      // Doctor notes always have an itineraryId according to schema
      function itineraryMemberForNote() {
        return resource.data.itineraryId != null &&
               exists(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)) &&
               isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(resource.data.itineraryId)));
      }
      
      // Allow read if user is a member of the parent itinerary or is admin
      // For queries, Firestore checks each document individually
      allow read: if isAuthenticated() && 
                     (!resource.exists || 
                      isAdmin() ||
                      (itineraryMemberForNote() && isNotDeleted()));
      
      // Allow create if user is a member of the target itinerary and required fields are present, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       request.resource.data.content is string &&
                       request.resource.data.content.size() > 0 &&
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        (request.resource.data.itineraryId != null &&
                         exists(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)) &&
                         isItineraryMemberDoc(get(/databases/$(database)/documents/itineraries/$(request.resource.data.itineraryId)))));
      
      // Allow update if user is a member of the parent itinerary and doesn't change ownership or soft-delete state
      allow update: if isAuthenticated() && 
                       itineraryMemberForNote() &&
                       request.resource.data.created.by == resource.data.created.by &&
                       request.resource.data.isDeleted == resource.data.isDeleted;
      
      // Allow delete (soft delete) if user is a member of the parent itinerary or is admin
      allow delete: if isAuthenticated() && (itineraryMemberForNote() || isAdmin());
    }

    // Invitations collection
    match /invitations/{invitationId} {
      // Allow read if user is the inviter or invitee, or if user is admin
      allow read: if isAuthenticated() && 
                     (isAdmin() ||
                      resource.data.invitedBy == request.auth.uid ||
                      resource.data.inviteeIdentifier == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email);
      
      // Allow create if user is the inviter, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       (isAdmin() ||
                        request.resource.data.invitedBy == request.auth.uid);
      
      // Allow update if user is the inviter or invitee (for accepting/declining)
      allow update: if isAuthenticated() && 
                       (resource.data.invitedBy == request.auth.uid ||
                        resource.data.inviteeIdentifier == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email);
      
      // Allow delete if user is the inviter or is admin
      allow delete: if isAuthenticated() && 
                       (resource.data.invitedBy == request.auth.uid || isAdmin());
    }

    // Itinerary Shares collection
    match /itineraryShares/{shareId} {
      // Allow read if user is the sharer or sharee and it's not deleted, or if user is admin
      allow read: if isAuthenticated() && 
                     (isAdmin() ||
                      ((resource.data.sharedWith == request.auth.uid ||
                        resource.data.sharedBy == request.auth.uid) &&
                       isNotDeleted()));
      
      // Allow create if user is the sharer, or if admin creates for any user
      allow create: if isAuthenticated() && 
                       willNotBeDeleted() &&
                       (isAdmin() ||
                        request.resource.data.sharedBy == request.auth.uid);
      
      // Allow update if user is the sharer
      allow update: if isAuthenticated() && 
                       resource.data.sharedBy == request.auth.uid &&
                       request.resource.data.sharedBy == resource.data.sharedBy;
      
      // Allow delete if user is the sharer or sharee or is admin
      allow delete: if isAuthenticated() && 
                       (resource.data.sharedBy == request.auth.uid ||
                        resource.data.sharedWith == request.auth.uid ||
                        isAdmin());
    }

    // Specialties collection
    match /specialties/{specialtyId} {
      // Allow read for all authenticated users (including queries)
      allow read: if isAuthenticated();
      // Allow create for authenticated users
      allow create: if isAuthenticated() && 
                       request.resource.data.name is string &&
                       request.resource.data.name.size() > 0;
      // Allow update for authenticated users
      allow update: if isAuthenticated() && 
                       request.resource.data.name is string &&
                       request.resource.data.name.size() > 0;
      // Allow delete for authenticated users (admins can delete any, others can delete their own)
      allow delete: if isAuthenticated();
    }

    // Frequency Options collection
    match /frequencyOptions/{optionId} {
      // TEMPORARILY DISABLED RULES FOR INITIALIZATION
      // TODO: Re-enable proper rules after initialization is complete
      // Allow all operations for authenticated users (no validation)
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
      
      // Rules to re-enable after initialization:
      // allow read: if isAuthenticated() && 
      //                (!resource.exists || resource.data.isActive == true);
      // allow create: if isAuthenticated() && 
      //                 request.resource.data.label is string &&
      //                 request.resource.data.label.size() > 0 &&
      //                 request.resource.data.intervalValue is number &&
      //                 request.resource.data.intervalValue >= 0 &&
      //                 request.resource.data.intervalUnit is string &&
      //                 request.resource.data.intervalUnit in ['hour', 'day', 'week', 'month', 'as_needed'] &&
      //                 request.resource.data.displayOrder is int &&
      //                 request.resource.data.displayOrder >= 0;
      // allow update: if isAuthenticated() && [same validation as create]
      // allow delete: if false;
    }

    // Notification Settings collection
    match /notificationSettings/{settingsId} {
      // Allow read for all authenticated users (needed for Cloud Functions)
      allow read: if isAuthenticated();
      
      // Allow create/update only for admins
      // Using merge: true means it could be either create or update
      allow create, update: if isAuthenticated() && 
                              isAdmin() &&
                              request.resource.data.emailEnabled is bool &&
                              request.resource.data.smsEnabled is bool;
      
      // Do not allow delete (settings should persist)
      allow delete: if false;
    }
  }
}
